const game = require('secrecy_game');
const utils = require('secrecy_utils');
const nodeutil = require('util');
const fs = require('fs');

var server = {};

/**
 TODO:
 
	helper method to send a message to both the ruler and the host (if applicable)
 
 */

/**
 * Sets a rooms ruler (= elevated privileges)
 * and sends a message to the ruler, informing them about their luck.
 */
server.setRoomRuler = function(room, ruler) {
	if(ruler.ws.readyState == 1) {
		room.setRulerSocket(ruler.ws);		
		ruler.ws.send(utils.createMessage("ruler", "You are the ruler now."));
	}
};

/**
 * Called when a player tries to join a room.
 * If the room is empty, the "player" will become the "room", meaning this socket will be considered the host of the game.
 * If the room has no players but a host, the joining player will become the "ruler"
 * If the room has a host and a ruler, all other players will simply join
 *
 * TODO: find good terminology for room/host/player/ruler
 * TODO: don't send anything, just return a result code and handle the sending in the calling scope?
 */
server.onJoin = function(player, params) {
	if(game.getPlayerRoom(player.playerID) != undefined) {
		player.ws.send(utils.createMessage("info", "You can only join one room."));
		return;
	}
			
	var roomName = params[0];
	var room = game.getRoom(roomName);
	if(room == undefined) {
		player.ws.send(utils.createMessage("noroom", "This room does not exist."));
		console.log("[GAME] Room (" + roomName + ") does not exist.");
		return;
	}
	
	if(params.length != 2) {
		player.ws.send(utils.createMessage("joinerror", "Please don't do that."));
		return;
	}

	var playerAlias = params[1];		
	player.setName(playerAlias);

	if(room.isFresh()) {
		room.setRoomSocket(player.ws);
		player.ws.send(utils.createMessage("info", "You are the room. You are the fire."));
		server.writeLog(nodeutil.format("Room %s host joined.", room.roomCode));
		return;
	} else if (room.isLobby()) {
		var player = room.playerJoin(player.playerID);
		var rs = room.getRoomSocket();
		rs.send(utils.createMessage("joined", player.getName(), player.playerID, room.score.getPoints(player.playerID)));
		player.ws.send(utils.createMessage("joined", roomName));
		
		if(room.getPlayerCount() == 1) {
			server.setRoomRuler(room, player);
		}
		
		server.writeLog(nodeutil.format("Room %s player joined.", room.roomCode));
		
		return;
	} else {
		player.ws.send(utils.createMessage("roomBusy", roomName));
	}
}

/**
 * This is called when all players have given an answer and guessed the correct amount of yesses for the current question.
 */
server.questionFinished = function(room, question) {
	console.log("[" + room.roomCode + "] Question finished, calulating score...");
	question.updateScore(room.score);
	room.question = undefined;
		
	var rs = room.getRoomSocket();
	rs.send(utils.createMessage("collectionDone"));
	var ruler = room.getRulerSocket();
	if(ruler != undefined) {
		ruler.send(utils.createMessage("collectionDone"));
	}
}

/**
 * Writes the given line to the log file.
 */
server.writeLog = function(text) {
	var time = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '');
	var path = __dirname + '/../logs.txt';
	var message = nodeutil.format("[%s] %s\n", time, text);
	fs.appendFileSync(path, message);
}

/**
 * Called when a client sends a command.
 * TODO: use command pattern.
 * TODO: ignore case
 */
server.onCommand = function(ws, command, params) {
	var playerID = ws.secGameID;
	var player = game.getPlayer(playerID);
	
	/**
	 * CREATE Command
	 * The user wants to create a room.
	 * The expected behavior for a user who wants to create a room currently is,
	 * that he will join immediatley after the creation.
	 * TODO: skip the join step, immediatley make the creater a host -> throw them out of all rooms (if applicable) etc.
	 */
	if(command == "create") {
		var room = game.createRoom();
		if(room == undefined) {
			ws.send(utils.createMessage("exhausted", "Someone is creating too many games. Please try again in a few seconds."));
			return;	
		}
		
		ws.send(utils.createMessage("created", room.roomCode));
		server.writeLog(nodeutil.format("Room %s created.", room.roomCode));
		
		return;
	}
	
	/**
	 * The so called crash-pattern. Helps restarting the entire node server by crashing it from the API - nice
	 */
	if(command == "pleaseCrash") {
		crash.exe.start.lol();
		return;
	}

	/**
	 * Subsequent commands need a player to be defined. This will become redundant with the command pattern
	 */
	if(player == undefined) {
		console.log("[GAME] Command requires registered player: " + command);
		return;
	}
	
	/**
	 * A player wants to join -> see server.onJoin
	 */ 
	if(command == "join") {
		server.onJoin(player, params);
		return;
	}
	
	/**
	 * START command
	 * for host and ruler
	 * 
	 * Starts a round of the game.
	 * Informs players that they need to anwser the question
	 */
	if(command == "start") {
		var room = game.getPlayerRoom(player.playerID);
		if(room == undefined) {
			player.ws.send(utils.createMessage("info", "You must BE a room first."));
			return;
		}
		
		var rs = room.getRoomSocket();
		if(player.ws != rs && player.ws != room.getRulerSocket()) {
			player.ws.send(utils.createMessage("info", "You are not allowed to do that."));
			return;
		}
		
		rs.send(utils.createMessage("started"));
		
		room.startRound();
		room.sendToAll(utils.createMessage("collect"));
		return;
	}
	
	/**
	 * CANCEL command
	 * for host and ruler
	 * 
	 * Cancels the ongoing round (removes guesses/score/etc)
	 */
	if(command == "cancelRound") {
		var room = game.getPlayerRoom(player.playerID);
		if(room == undefined) {
			player.ws.send(utils.createMessage("info", "You must BE a room first."));
			return;
		}
		
		var rs = room.getRoomSocket();
		if(player.ws != rs && player.ws != room.getRulerSocket()) {
			player.ws.send(utils.createMessage("info", "You are not allowed to do that."));
			return;
		}
		
		rs.send(utils.createMessage("cancelled"));
				
		room.cancelRound();
		room.sendToAll(utils.createMessage("cancel"));
		return;
	}
	
	/**
	 * The ruler requests information about the game
	 * Currently this is only used to get the number of active players in the game, but this might change.
	 * Differebt parameters will give different information
	 * Be cautious not to reveal any "private" information that could be abused (if that even exists?)
	 */
	if(command == "rulerInfo") {
		var room = game.getPlayerRoom(player.playerID);
		if(room == undefined) {
			player.ws.send(utils.createMessage("info", "You must BE a room first."));
			return;
		}
		
		if(player.ws != room.getRoomSocket() && player.ws != room.getRulerSocket()) {
			player.ws.send(utils.createMessage("info", "You are not allowed to do that."));
			return;
		}
		
		player.ws.send(utils.createMessage("rulerInfo", params[0], room.getPlayerCount()));
		return;
	}
	
	/**
	 * REOPEN command
	 *
	 * Reopens a room for players to join.
	 * TODO: Send positive response, if the command went through, handle that message in the client code
	 */
	if(command == "reopen") {
		var room = game.getPlayerRoom(player.playerID);
		if(room == undefined) {
			player.ws.send(utils.createMessage("info", "You must BE a room first."));
			return;
		}
		
		var rs = room.getRoomSocket();
		if(player.ws != rs) {
			player.ws.send(utils.createMessage("info", "You are not allowed to do that."));
			return;
		}
		
		room.reopen();
		return;
	}
	
	/**
	 * COLLECT command
	 *
	 * A client will send this to give their yes/no answer to the question.
	 * 1 == yes, other == no
	 * 
	 * IMPORTANT: Never store information connecting the specific client to their answer
	 */
	if(command == "collect") {
		var room = game.getPlayerRoom(player.playerID);
		var question = room.question;
		if(question == undefined) {
			return;
		}
		
		question.addYesNo(params[0] == "1");
		
		var rs = room.getRoomSocket();
		rs.send(utils.createMessage("yesno", playerID));
		
		var playerCount = room.getPlayerCount();
		player.ws.send(utils.createMessage("guess", playerCount));
				
		return;
	}
	
	/**
	 * GUESS command
	 *
	 * A client will send this to give their guess (number of yesses) for the current round.
	 */
	if(command == "guess") {
		var room = game.getPlayerRoom(player.playerID);
		var question = room.question;
		if(question == undefined) {
			return;
		}
		
		question.addGuess(playerID, parseInt(params[0]));
		
		var rs = room.getRoomSocket();
		rs.send(utils.createMessage("guess", playerID));
		
		player.ws.send(utils.createMessage("guessed"));
		
		var playerCount = room.getPlayerCount();
		var guessCount = question.getGuessCount();
		if(playerCount == guessCount) {
			room.sendToAll(utils.createMessage("everyone guessed"));
			server.questionFinished(room, question);
		}
		
		return;
	}
	
	
	/**
	 * ENDROUND command
	 * for host and ruler
	 * 
	 * After all guesses/answers have been submitted, this command will send the new scores to the host to update the list
	 * After a short delay, a message will be sent, that the next round is ready.
	 */
	if(command == "endround") {
		var room = game.getPlayerRoom(player.playerID);
		if(room == undefined) {
			player.ws.send(utils.createMessage("info", "You must BE a room first."));
			return;
		}
		
		var rs = room.getRoomSocket();
		if(player.ws != rs && player.ws != room.getRulerSocket()) {
			player.ws.send(utils.createMessage("info", "You are not allowed to do that."));
			return;
		}
				
		var playerIDs = room.getPlayerIDs();
		for(var i = 0; i < playerIDs.length; i++) {
			var playerID = playerIDs[i];
			var player = room.getPlayer(playerID);
			if(player == undefined) {
				console.log("[" + room.roomCode + "] Player not found: " + playerID);
				continue;
			}
			
			player.ws.send(utils.createMessage("score", room.score.getLastRoundsPoints(playerID), room.score.getPoints(playerID)));
			rs.send(utils.createMessage("score", player.playerID, room.score.getLastRoundsPoints(playerID), room.score.getPoints(playerID)));
		}	
		
		rs.send(utils.createMessage("roundEnd"));
		
		setTimeout(function() {
			rs.send(utils.createMessage("readyForNewRound"));
			var ruler = room.getRulerSocket();
			if(ruler != undefined) {
				ruler.send(utils.createMessage("readyForNewRound"));
			}
		}, 3000);
		
		return;
	}

}

/**
 * Websockets can be passed into this class for participation in the game.
 * Websockets will automatically be registered as players and get a playerID
 */
server.handleSocketClient = function(ws) {
	ws.on('disconnect', function() {
      console.log('[SERVER] Got disconnect!');
	});
	
	/**
	 * When a socket closes, the player will be removed from the room they were in (for now*)
	 * Empty rooms will be deleted
	 * If the host leaves, everyone else will be kicked.
	 * If the ruler leaves, a new ruler is chosen randomly.
	 */
	ws.on('close', function() {
		var playerID = ws.secGameID;
	
		console.log('[SERVER] Got close!');
		
		var room = game.getPlayerRoom(playerID);
		if(room == undefined) {
			return;
		}
		
		var rs = room.getRoomSocket();
		if(rs == ws || room.isEmpty()) {
			game.deleteRoom(room);
			console.log("[GAME] Deleted: " + room.roomCode);
			server.writeLog(nodeutil.format("Room %s deleted.", room.roomCode));
			return;
		}

		var player = room.getPlayer(playerID);
		if(player == undefined) {
			return;
		}

		if(rs != undefined && rs.readyState == 1) {
			rs.send(utils.createMessage("left", player.getName(), player.playerID));
		}
		
		server.writeLog(nodeutil.format("Room %s player left.", room.roomCode));
				
		room.playerLeft(playerID);
		game.unsetPlayerRoom(playerID);
		
		if(room.getRulerSocket() == player.ws) {
			var newRuler = room.getRandomPlayer();
			if(newRuler != undefined) {
				server.setRoomRuler(room, newRuler);
			}
		}
	});
		
	/**
	 * Clients can send commands to this server.
	 * TODO: change command format to JSON
	 */
	ws.on('message', message => {
		var splitsies = message.split(/:(.+)/);
		
		var command = splitsies[0];
			
		var params = [];
		if(splitsies.length > 1) {
			params = splitsies[1].split(';');
		}	
		
		server.onCommand(ws, command, params);
	});
	
	game.registerPlayer(ws);
}

/**
 * What is this?
 */
server.onRoomClosed = function(room, message) {
	var ws = room.getRoomSocket();
	if(ws != undefined) {
		ws.send("Room closed: " + message);
	}
}

module.exports = server;